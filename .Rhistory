ClimbTime,
ClimbDuration,
Tide_Table,
.x)))
is.null(check)
check != nrow(real_times_and_heights(climb_start, climb_duration, tide_height_df))
if_else(is.null(check) | check != nrow(real_times_and_heights(climb_start, climb_duration, tide_height_df)),  FALSE, TRUE)
climbable_check <- function(climb_start, climb_duration, tide_height_df, height_limit){
check <- (real_times_and_heights(climb_start, climb_duration, tide_height_df) |>
pluck("h") > height_limit) |>
summary() |>
pluck("TRUE")
if_else(is.null(check) ,FALSE, if_else( check != nrow(real_times_and_heights(climb_start, climb_duration, tide_height_df)),  FALSE, TRUE))
}
test <- get_limit_table(Island_Climbing,
Tide_Table,
ClimbTime)  %>%  mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x)))
debug(climbable_check)
test <- get_limit_table(Island_Climbing,
Tide_Table,
ClimbTime)  %>%  mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x)))
if_else(is.null(check) ,FALSE, 2)
if_else(is.null(check) ,FALSE, TRUE)
climbable_check <- function(climb_start, climb_duration, tide_height_df, height_limit){
check <- (real_times_and_heights(climb_start, climb_duration, tide_height_df) |>
pluck("h") > height_limit) |>
summary() |>
pluck("TRUE")
if_else(is.null(check) ,"FALSE", if_else( check != nrow(real_times_and_heights(climb_start, climb_duration, tide_height_df)),  "FALSE", "TRUE"))
}
test <- get_limit_table(Island_Climbing,
Tide_Table,
ClimbTime)  %>%  mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x)))
test
test <- get_limit_table(Island_Climbing,
Tide_Table,
ClimbTime)  %>%  mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x)))
debug(climbable_check)
test <- get_limit_table(Island_Climbing,
Tide_Table,
ClimbTime)  %>%  mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x)))
check
if_else(is.null(Check), 1,2)
if_else(is.null(check), 1,2)
if_else(is.null(check), 1,if(check!= 2,3)
if_else(is.null(check), 1,if(check!= 2))
if_else(is.null(check), 1,if(check != 2,2))
if_else(is.null(check), 1,if(check != 2))
if_else(is.null(check), 1,if_else(check != 2,2,3))
NULL ==2
climbable_check <- function(climb_start, climb_duration, tide_height_df, height_limit){
check <- (real_times_and_heights(climb_start, climb_duration, tide_height_df) |>
pluck("h") > height_limit) |>
summary() |>
pluck("TRUE")
if(is.null(check)){FALSE} else if(check != nrow(real_times_and_heights(climb_start, climb_duration, tide_height_df))){FALSE} else{TRUE}
#if_else(is.null(check) ,"FALSE", if_else( check != nrow(real_times_and_heights(climb_start, climb_duration, tide_height_df)),  "FALSE", "TRUE"))
}
test <- get_limit_table(Island_Climbing,
Tide_Table,
ClimbTime)  %>%  mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x)))
test
test %>% View()
test$access
test %>% filter(access == TRUE)
tide_filter <- function(filtered_climb_list, tide_table, climb_time, climb_duration){
get_limit_table(filtered_climb_list,
tide_table,
climb_time) |>
mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x))
) |>
filter(access = TRUE) |>
select(-access)
}
tide_filter(Island_Climbing, Tide_Table, ClimbTime, ClimbDuration)
test <- get_limit_table(Island_Climbing,
Tide_Table,
ClimbTime)  %>%  mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x)))
test
tide_filter <- function(filtered_climb_list, tide_table, climb_time, climb_duration){
tide_limit<- get_limit_table(filtered_climb_list,
tide_table,
climb_time) |>
mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x))
)
left_join(filtered_climb_list,
tide_limit,
by = c('Tide Season' = 'Tide Season',
'Tide Height' = 'Tide Height',
'Hours to be inaccesible' = 'Hours to be inaccesible')
)
}
tide_filter(Island_Climbing, Tide_Table, ClimbTime, ClimbDuration)
tide_filter(Island_Climbing, Tide_Table, ClimbTime, ClimbDuration) %>% select('Climb Name', access)
tide_filter(Island_Climbing, Tide_Table, ClimbTime, ClimbDuration) %>% select('Climb Name', access) %>% filter(access == TRUE)
tide_filter(Island_Climbing, Tide_Table, ClimbTime, ClimbDuration) %>%filter(access == TRUE)
tide_filter(Island_Climbing, Tide_Table, ClimbTime, ClimbDuration) %>%filter(access == TRUE) %>% select(-access)
tide_filter <- function(filtered_climb_list, tide_table, climb_time, climb_duration){
tide_limit<- get_limit_table(filtered_climb_list,
tide_table,
climb_time) |>
mutate(access = map(height_limit,
~climbable_check(
ClimbTime,
ClimbDuration,
Tide_Table,
.x))
)
left_join(filtered_climb_list,
tide_limit,
by = c('Tide Season' = 'Tide Season',
'Tide Height' = 'Tide Height',
'Hours to be inaccesible' = 'Hours to be inaccesible')
)|>
filter(access == TRUE)|>
select(-access)
}
Climbing_Filter <- function(Name_Of_Area = NULL,
Climb_Name = NULL,
Climb_Grade = NULL,
Hardest_Move = NULL,
Tide_Season = NULL,
Tide_Height = NULL,
Hours_Innacessible = NULL,
Lead = NULL,
Seconded = NULL,
limit_by_tide = NULL){
Filtered_Data <-Island_Climbing |> mutate(id = row_number())
if(!is.null(Name_Of_Area)){
Filtered_Data <- Filtered_Data %>% filter(Filtered_Data$`Name Of Area` %in% Name_Of_Area)
}
if(!is.null(Climb_Name)){
Filtered_Data <- Filtered_Data %>% filter(Filtered_Data$`Climb Name` %in% Climb_Name)
}
if(!is.null(Climb_Grade)){
Filtered_Data <- Filtered_Data %>% filter(Filtered_Data$`Overall_Grade_1` %in% Climb_Grade | Filtered_Data$`Overall_Grade_2` %in% Climb_Grade)
}
if(!is.null(Hardest_Move)){
Filtered_Data <- Filtered_Data %>% filter(Filtered_Data$`Hardest_Move_1` %in% Hardest_Move | Filtered_Data$`Hardest_Move_2` %in% Hardest_Move)
}
if(!is.null(Tide_Season)){
Filtered_Data <- Filtered_Data %>% filter(Filtered_Data$`Tide Season` %in% c(Tide_Season,"All"))
}
if(!is.null(Tide_Height)){
Filtered_Data <- Filtered_Data %>% filter(Filtered_Data$`Tide Height` %in% c(Tide_Height,"All"))
}
if(!is.null(Hours_Innacessible)){
Filtered_Data <- Filtered_Data %>% filter(Filtered_Data$`Hours Innaccessible` >= Hours_Innacessible)
}
if(!is.null(Lead)){
Filtered_Data <- Filtered_Data %>% filter(!is.na(Lead))
}
if(!is.null(Seconded)){
Filtered_Data <- Filtered_Data %>% filter(!is.na(Seconded))
}
if(!is.null(limit_by_tide)){
Filtered_Data <- tide_filter(Filtered_Data, Tide_Table, ClimbTime, ClimbDuration)
}
Filtered_Data %>% select(`Name Of Area` , `Climb Name`, id)
}
#=====
library(readr)
library(here)
Island_Climbing<-read_rds(paste0(here(),"/data/Island_Climbing.rds"))
source(here("R","functions.R"))
source(here("R","old_data_editing_code.R"))
#Desired climb time
ClimbTime <- hm("06:00")
ClimbDuration <- hm("2:00")
source(here("R","web_scraping.R"))
source(here("R","tide_function.R"))
#source(here("R","app_build.R"))#<--- Used for ShinyApp later on when this all works
# Code to enter lead or second climb and date
Add_Lead <- function(ClimbName, ClimbDate){
Island_Climbing$Lead[Island_Climbing$`Climb Name`==ClimbName] <- "Y"
Island_Climbing$Date_Lead[Island_Climbing$`Climb Name`==ClimbName] <- ClimbDate
}
Add_Second <- function(ClimbName, ClimbDate){
Island_Climbing$`2nd`[Island_Climbing$`Climb Name`==ClimbName] <- "Y"
Island_Climbing$Date_Seconded[Island_Climbing$`Climb Name`==ClimbName] <- ClimbDate
}
#====
Map_Gen <- function(area_name = NULL,
climb_name = NULL,
climb_grade = NULL,
hardest_move = NULL,
tide_season = NULL,
tide_height = NULL,
hours_innacessible = NULL,
is_lead = NULL,
is_seconded = NULL,
limit_by_tide = NULL) {
FilterList <- Climbing_Filter(Name_Of_Area = area_name,
Climb_Name = climb_name,
Climb_Grade = climb_grade,
Hardest_Move = hardest_move,
Tide_Season = tide_season,
Tide_Height = tide_height,
Hours_Innacessible = hours_innacessible,
Lead = is_lead,
Seconded= is_seconded,
limit_by_tide = limit_by_tide)
FilteredList_Group_Counted <- Island_Climbing |>
filter(row_number() %in% FilterList$id) |>
group_by(`Name Of Area`) |>
mutate(number = n()) |>
ungroup()
#Creating a colour wheel with the number of distinct values for no. of climbs
MyColour <- viridis_pal(option = "C")(
nrow(unique(FilteredList_Group_Counted|> select(number)))
)
FilteredList_Group_Counted <- merge(FilteredList_Group_Counted|>
select(number) |>
unique() |>
arrange(number) |>
mutate(id=row_number()),
FilteredList_Group_Counted,
by="number")
pal <- colorFactor(palette = MyColour, domain=FilteredList_Group_Counted$number)
leaflet()|>
addTiles()|>
addCircles(data=
FilteredList_Group_Counted,
lat = ~Latitide,
lng = ~Longitude,
radius =
5*1.02^FilteredList_Group_Counted$number,
fillOpacity = 1,
popup = FilteredList_Group_Counted$`Name Of Area`,
color = "black",
#fillColor = "white",
fillColor = MyColour[FilteredList_Group_Counted$id],
weight = 0.0001+1.02^FilteredList_Group_Counted$number,
opacity = 0.9,
stroke=TRUE,
)|>
addLegend("bottomright",
pal = pal,
values = unique(FilteredList_Group_Counted$number),
title = "# Of Climbs",
labFormat = labelFormat(prefix = ""),
opacity = 1)
}
#Need to adjust the height column so that it matches the maximum accessible (not the max value).
Island_Climbing |>  select(`Tide Season`, `Tide Height`, `Hours to be inaccesible`) |>  unique()
Tide_Restriction <- function(ClimbTime, ClimbDuration) {
if (Tide_Season == "Neap") {
Island_Climbing |>  filter(`Tide Season` == "Neap" & 1)
}
if (Tide_Season == "Spring") {
Island_Climbing |>  filter(`Tide Season` == "Spring")
}
if (Tide_Season == "All") {
}
}
Tide_Function <- function(height, time, duration){
ifelse(height == "All", NULL , ifelse(height == "High" , 2 , 3 ) )
}
Island_Climbing |>  mutate(
Test = ifelse(`Tide Season`== "All",
1,
ifelse(
`Tide Season`== "Spring",
ifelse(
Tide_Season == "Spring",
"a",
"b"
),
ifelse(Tide_Season == "Neap", "c", "d")))
) |>  select(Test) |>  unique() |>  View(
)
Tide_Season == "Spring"
Map_Gen(climb_grade = "E2", limit_by_tide = no)
Map_Gen(climb_grade = "E2", limit_by_tide = "no")
Map_Gen(climb_grade = "E2")
#=====
library(readr)
library(here)
Island_Climbing<-read_rds(paste0(here(),"/data/Island_Climbing.rds"))
source(here("R","functions.R"))
source(here("R","old_data_editing_code.R"))
#Desired climb time
ClimbTime <- hm("06:00")
ClimbDuration <- hm("2:00")
source(here("R","web_scraping.R"))
source(here("R","tide_function.R"))
#source(here("R","app_build.R"))#<--- Used for ShinyApp later on when this all works
# Code to enter lead or second climb and date
Add_Lead <- function(ClimbName, ClimbDate){
Island_Climbing$Lead[Island_Climbing$`Climb Name`==ClimbName] <- "Y"
Island_Climbing$Date_Lead[Island_Climbing$`Climb Name`==ClimbName] <- ClimbDate
}
Add_Second <- function(ClimbName, ClimbDate){
Island_Climbing$`2nd`[Island_Climbing$`Climb Name`==ClimbName] <- "Y"
Island_Climbing$Date_Seconded[Island_Climbing$`Climb Name`==ClimbName] <- ClimbDate
}
#====
Map_Gen <- function(area_name = NULL,
climb_name = NULL,
climb_grade = NULL,
hardest_move = NULL,
tide_season = NULL,
tide_height = NULL,
hours_innacessible = NULL,
is_lead = NULL,
is_seconded = NULL,
limit_by_tide = NULL) {
FilterList <- Climbing_Filter(Name_Of_Area = area_name,
Climb_Name = climb_name,
Climb_Grade = climb_grade,
Hardest_Move = hardest_move,
Tide_Season = tide_season,
Tide_Height = tide_height,
Hours_Innacessible = hours_innacessible,
Lead = is_lead,
Seconded= is_seconded,
limit_by_tide = limit_by_tide)
FilteredList_Group_Counted <- Island_Climbing |>
filter(row_number() %in% FilterList$id) |>
group_by(`Name Of Area`) |>
mutate(number = n()) |>
ungroup()
#Creating a colour wheel with the number of distinct values for no. of climbs
MyColour <- viridis_pal(option = "C")(
nrow(unique(FilteredList_Group_Counted|> select(number)))
)
FilteredList_Group_Counted <- merge(FilteredList_Group_Counted|>
select(number) |>
unique() |>
arrange(number) |>
mutate(id=row_number()),
FilteredList_Group_Counted,
by="number")
pal <- colorFactor(palette = MyColour, domain=FilteredList_Group_Counted$number)
leaflet()|>
addTiles()|>
addCircles(data=
FilteredList_Group_Counted,
lat = ~Latitide,
lng = ~Longitude,
radius =
5*1.02^FilteredList_Group_Counted$number,
fillOpacity = 1,
popup = FilteredList_Group_Counted$`Name Of Area`,
color = "black",
#fillColor = "white",
fillColor = MyColour[FilteredList_Group_Counted$id],
weight = 0.0001+1.02^FilteredList_Group_Counted$number,
opacity = 0.9,
stroke=TRUE,
)|>
addLegend("bottomright",
pal = pal,
values = unique(FilteredList_Group_Counted$number),
title = "# Of Climbs",
labFormat = labelFormat(prefix = ""),
opacity = 1)
}
#Need to adjust the height column so that it matches the maximum accessible (not the max value).
# if neap and low then for spring choose 1h after mid point of tide times (tide moving down)
# if neap and high then for spring choose 1h after mid-point of tide times (tide moving upwards)
#If spring high , allow all neap tides
#If spring low, disallow all neap tides
####
# API STUFF
####
base<- "https://tics.seeker.gg/api/event"
raw_results <-GET(base)
converted_content <- content(raw_results,as="text")
converted_json <- fromJSON(converted_content)
#=====
library(readr)
library(here)
Island_Climbing<-read_rds(paste0(here(),"/data/Island_Climbing.rds"))
source(here("R","functions.R"))
source(here("R","old_data_editing_code.R"))
#Desired climb time
ClimbTime <- hm("06:00")
ClimbDuration <- hm("2:00")
source(here("R","web_scraping.R"))
source(here("R","tide_function.R"))
#source(here("R","app_build.R"))#<--- Used for ShinyApp later on when this all works
# Code to enter lead or second climb and date
Add_Lead <- function(ClimbName, ClimbDate){
Island_Climbing$Lead[Island_Climbing$`Climb Name`==ClimbName] <- "Y"
Island_Climbing$Date_Lead[Island_Climbing$`Climb Name`==ClimbName] <- ClimbDate
}
Add_Second <- function(ClimbName, ClimbDate){
Island_Climbing$`2nd`[Island_Climbing$`Climb Name`==ClimbName] <- "Y"
Island_Climbing$Date_Seconded[Island_Climbing$`Climb Name`==ClimbName] <- ClimbDate
}
#====
Map_Gen <- function(area_name = NULL,
climb_name = NULL,
climb_grade = NULL,
hardest_move = NULL,
tide_season = NULL,
tide_height = NULL,
hours_innacessible = NULL,
is_lead = NULL,
is_seconded = NULL,
limit_by_tide = NULL) {
FilterList <- Climbing_Filter(Name_Of_Area = area_name,
Climb_Name = climb_name,
Climb_Grade = climb_grade,
Hardest_Move = hardest_move,
Tide_Season = tide_season,
Tide_Height = tide_height,
Hours_Innacessible = hours_innacessible,
Lead = is_lead,
Seconded= is_seconded,
limit_by_tide = limit_by_tide)
FilteredList_Group_Counted <- Island_Climbing |>
filter(row_number() %in% FilterList$id) |>
group_by(`Name Of Area`) |>
mutate(number = n()) |>
ungroup()
#Creating a colour wheel with the number of distinct values for no. of climbs
MyColour <- viridis_pal(option = "C")(
nrow(unique(FilteredList_Group_Counted|> select(number)))
)
FilteredList_Group_Counted <- merge(FilteredList_Group_Counted|>
select(number) |>
unique() |>
arrange(number) |>
mutate(id=row_number()),
FilteredList_Group_Counted,
by="number")
pal <- colorFactor(palette = MyColour, domain=FilteredList_Group_Counted$number)
leaflet()|>
addTiles()|>
addCircles(data=
FilteredList_Group_Counted,
lat = ~Latitide,
lng = ~Longitude,
radius =
5*1.02^FilteredList_Group_Counted$number,
fillOpacity = 1,
popup = FilteredList_Group_Counted$`Name Of Area`,
color = "black",
#fillColor = "white",
fillColor = MyColour[FilteredList_Group_Counted$id],
weight = 0.0001+1.02^FilteredList_Group_Counted$number,
opacity = 0.9,
stroke=TRUE,
)|>
addLegend("bottomright",
pal = pal,
values = unique(FilteredList_Group_Counted$number),
title = "# Of Climbs",
labFormat = labelFormat(prefix = ""),
opacity = 1)
}
#Need to adjust the height column so that it matches the maximum accessible (not the max value).
# if neap and low then for spring choose 1h after mid point of tide times (tide moving down)
# if neap and high then for spring choose 1h after mid-point of tide times (tide moving upwards)
#If spring high , allow all neap tides
#If spring low, disallow all neap tides
####
# API STUFF
####
base<- "https://tics.seeker.gg/api/event"
raw_results <-GET(base)
converted_content <- content(raw_results,as="text")
converted_json <- fromJSON(converted_content)
Map_Gen(climb_grade = "E2", limit_by_tide = "no")
Map_Gen(climb_grade = "E2", limit_by_tide = "yes")
